package generator

import (
	"bytes"
	"context"
	"fmt"
	"strings"
	"text/template"

	"github.com/elliotchance/pie/v2"

	"github.com/labd/mach-composer/internal/config"
	"github.com/labd/mach-composer/internal/variables"
)

// renderSite is responsible for generating the `site.tf` file. Therefore it is
// the main entrypoint for generating the terraform file for each site.
func renderSite(ctx context.Context, cfg *config.MachConfig, site *config.SiteConfig) (string, error) {
	result := []string{
		"# This file is auto-generated by MACH composer",
		fmt.Sprintf("# Site: %s", site.Identifier),
	}

	// Render the terraform config
	val, err := renderTerraformConfig(cfg, site)
	if err != nil {
		return "", fmt.Errorf("renderTerraformConfig: %w", err)
	}
	result = append(result, val)

	// Render all the global resources
	val, err = renderTerraformResources(cfg, site)
	if err != nil {
		return "", fmt.Errorf("failed to render resources: %w", err)
	}
	result = append(result, val)

	// Render every component (incuding component specific resources)
	for i := range site.Components {
		component := &site.Components[i]
		val, err := renderComponent(ctx, cfg, site, component)
		if err != nil {
			return "", fmt.Errorf("failed to render component %s: %w", component.Name, err)
		}
		result = append(result, val)
	}

	content := strings.Join(result, "\n")
	return content, nil
}

// renderTerraformConfig renders the terraform settings block which defines the
// remote state to be used and the providers to be loaded.
func renderTerraformConfig(cfg *config.MachConfig, site *config.SiteConfig) (string, error) {
	providers := []string{}
	for _, plugin := range cfg.Plugins.All() {
		content, err := plugin.RenderTerraformProviders(site.Identifier)
		if err != nil {
			return "", fmt.Errorf("plugin %s failed to render providers: %w", plugin.Name, err)
		}
		if content != "" {
			providers = append(providers, content)
		}
	}

	backendConfig := ""
	if cfg.Global.TerraformStateProvider != "" {
		statePlugin, err := cfg.Plugins.Get(cfg.Global.TerraformStateProvider)
		if err != nil {
			return "", fmt.Errorf("failed to resolve plugin for terraform state: %w", err)
		}

		backendConfig, err = statePlugin.RenderTerraformStateBackend(site.Identifier)
		if err != nil {
			return "", fmt.Errorf("failed to render backend config: %w", err)
		}
	}

	tpl := `
		terraform {
			{{ .BackendConfig }}

			required_providers {
				{{ range $provider := .Providers }}
					{{ $provider }}
				{{ end }}

				{{ if .IncludeSOPS }}
				sops = {
					source = "carlpett/sops"
					version = "~> 0.5"
				}
				{{ end }}
			}
	  }
	`
	templateContext := struct {
		Providers     []string
		BackendConfig string
		IncludeSOPS   bool
	}{
		Providers:     providers,
		BackendConfig: backendConfig,
		IncludeSOPS:   cfg.Variables.HasEncrypted(site.Identifier),
	}
	return renderGoTemplate(tpl, templateContext)
}

func renderTerraformResources(cfg *config.MachConfig, site *config.SiteConfig) (string, error) {
	resources := []string{}
	for _, plugin := range cfg.Plugins.All() {
		content, err := plugin.RenderTerraformResources(site.Identifier)
		if err != nil {
			return "", fmt.Errorf("plugin %s failed to render resources: %w", plugin.Name, err)
		}

		if content != "" {
			resources = append(resources, content)
		}
	}

	tpl := `
		{{ range $fs := .FileSources }}
			data "local_file" "variables" {
				filename = "{{ $fs.Filename }}"
			}

			data "sops_external" "variables" {
				source     = data.local_file.variables.content
				input_type = "yaml"
			}
		{{ end }}

		# Plugins
		{{ range $resource := .Resources }}
			{{ $resource }}
		{{ end }}
	`
	templateContext := struct {
		Resources   []string
		FileSources []variables.FileSource
	}{
		Resources:   resources,
		FileSources: cfg.Variables.GetEncryptedSources(site.Identifier),
	}
	return renderGoTemplate(tpl, templateContext)
}

// renderComponent uses templates/component.tf to generate a terraform snippet
// for each component
func renderComponent(_ context.Context, cfg *config.MachConfig, site *config.SiteConfig, component *config.SiteComponent) (string, error) {

	tc := struct {
		ComponentName       string
		SiteName            string
		Environment         string
		Source              string
		PluginResources     []string
		PluginProviders     []string
		PluginDependsOn     []string
		PluginVariables     []string
		ComponentVariables  string
		ComponentSecrets    string
		ComponentVersion    string
		HasCloudIntegration bool
	}{
		ComponentName:    component.Name,
		ComponentVersion: component.Definition.Version,
		SiteName:         site.Identifier,
		Environment:      cfg.Global.Environment,
		Source:           component.Definition.Source,
		PluginResources:  []string{},
		PluginVariables:  []string{},
		PluginDependsOn:  []string{},
		PluginProviders:  []string{},
	}

	for _, plugin := range cfg.Plugins.All() {
		if !pie.Contains(component.Definition.Integrations, plugin.Name) {
			continue
		}
		plugin, err := cfg.Plugins.Get(plugin.Name)
		if err != nil {
			return "", err
		}

		cr, err := plugin.RenderTerraformComponent(site.Identifier, component.Name)
		if err != nil {
			return "", fmt.Errorf("plugin %s failed to render component: %w", plugin.Name, err)
		}

		if cr == nil {
			continue
		}

		tc.PluginResources = append(tc.PluginResources, cr.Resources)
		tc.PluginVariables = append(tc.PluginVariables, cr.Variables)
		tc.PluginProviders = append(tc.PluginProviders, cr.Providers...)
		tc.PluginDependsOn = append(tc.PluginDependsOn, cr.DependsOn...)
	}

	tpl := `
		# Module: {{ .ComponentName }}
		{{ range $resource := .PluginResources }}
			{{ $resource }}
		{{ end }}

		module "{{ .ComponentName }}" {
			source = "{{ .Source }}"

			{{ if .ComponentVariables }}
				{{ .ComponentVariables }}
			{{ end }}

			{{ if .ComponentSecrets }}
				{{ .ComponentSecrets }}
			{{ end }}

			{{ if .HasCloudIntegration }}
			component_version       = "{{ .ComponentVersion }}"
			environment             = "{{ .Environment }}"
			site                    = "{{ .SiteName }}"
			tags                    = local.tags
			{{ end }}

			{{ range $item := .PluginVariables }}
				{{ $item }}
			{{ end }}

			{{ if .PluginProviders }}
			providers = {
				{{ range $item := .PluginProviders }}
					{{ $item }},
				{{ end }}
			}
			{{ end }}

			{{ if .PluginDependsOn }}
			depends_on = [
				{{ range $item := .PluginDependsOn }}
					{{ $item }},
				{{ end }}
			]
			{{ end }}
		}
	`

	if component.HasCloudIntegration(&cfg.Global) {
		tc.HasCloudIntegration = true
		tc.ComponentVariables = "variables = {}"
		tc.ComponentSecrets = "secrets = {}"
	}

	if len(component.Variables) > 0 {
		val, err := serializeToHCL("variables", component.Variables)
		if err != nil {
			return "", err
		}
		tc.ComponentVariables = val
	}
	if len(component.Secrets) > 0 {
		val, err := serializeToHCL("secrets", component.Secrets)
		if err != nil {
			return "", err
		}
		tc.ComponentSecrets = val
	}

	if component.Definition.UseVersionReference() {
		tc.Source += fmt.Sprintf("?ref=%s", component.Definition.Version)
	}

	return renderGoTemplate(tpl, tc)
}

func renderGoTemplate(t string, data any) (string, error) {
	tpl, err := template.New("template").Parse(t)
	if err != nil {
		return "", err
	}

	var content bytes.Buffer
	if err := tpl.Execute(&content, data); err != nil {
		return "", err
	}
	return content.String(), nil
}
