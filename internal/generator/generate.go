package generator

import (
	"embed"
	"fmt"
	"strings"

	"github.com/elliotchance/pie/v2"
	"github.com/flosch/pongo2/v5"

	"github.com/labd/mach-composer/internal/config"
	"github.com/labd/mach-composer/internal/plugins/shared"
	"github.com/labd/mach-composer/internal/variables"
)

//go:embed templates/*
var templates embed.FS

type TemplateRenderer struct {
	templateSet *pongo2.TemplateSet

	servicesTemplate  *pongo2.Template
	componentTemplate *pongo2.Template
	tfConfigTemplate  *pongo2.Template
}

var renderer TemplateRenderer

func init() {
	renderer.templateSet = pongo2.NewSet("", &shared.EmbedLoader{Content: templates})
	renderer.servicesTemplate = pongo2.Must(renderer.templateSet.FromFile("services.tf"))
	renderer.componentTemplate = pongo2.Must(renderer.templateSet.FromFile("component.tf"))
	renderer.tfConfigTemplate = pongo2.Must(renderer.templateSet.FromFile("config.tf"))
}

func Render(cfg *config.MachConfig, site *config.Site) (string, error) {
	result := []string{
		"# This file is auto-generated by MACH composer",
		fmt.Sprintf("# Site: %s", site.Identifier),
	}

	if val, err := renderTerraformConfig(cfg, site); err == nil {
		result = append(result, val)
	} else {
		return "", err
	}

	if val, err := renderServices(cfg, site); err == nil {
		result = append(result, val)
	} else {
		return "", err
	}

	// Add components
	for i := range site.Components {
		component := &site.Components[i]
		if val, err := renderComponent(cfg, site, component); err == nil {
			result = append(result, val)
		} else {
			return "", fmt.Errorf("failed to render component %s: %w", component.Name, err)
		}
	}

	content := strings.Join(result, "\n")
	return content, nil
}

func renderTerraformConfig(cfg *config.MachConfig, site *config.Site) (string, error) {
	providers := []string{}
	for _, plugin := range cfg.Plugins.All() {
		content, err := plugin.TerraformRenderProviders(site.Identifier)
		if err != nil {
			return "", err
		}
		providers = append(providers, content)
	}

	statePlugin, err := cfg.Plugins.Get(cfg.Global.TerraformStateProvider)
	if err != nil {
		return "", fmt.Errorf("failed to resolve plugin for terraform state: %w", err)
	}

	backendConfig, err := statePlugin.TerraformRenderStateBackend(site.Identifier)
	if err != nil {
		return "", fmt.Errorf("failed to render backend config: %w", err)

	}

	return renderer.tfConfigTemplate.Execute(pongo2.Context{
		"global":         cfg.Global,
		"site":           site,
		"variables":      cfg.Variables,
		"providers":      providers,
		"backend_config": backendConfig,
	})
}

func renderServices(cfg *config.MachConfig, site *config.Site) (string, error) {
	resources := []string{}
	for _, plugin := range cfg.Plugins.All() {
		content, err := plugin.TerraformRenderResources(site.Identifier)
		if err != nil {
			return "", err
		}
		resources = append(resources, content)
	}

	return renderer.servicesTemplate.Execute(pongo2.Context{
		"global":    cfg.Global,
		"site":      site,
		"variables": cfg.Variables,
		"resources": resources,
	})
}

// renderComponent uses templates/component.tf to generate a terraform snippet
// for each component
func renderComponent(cfg *config.MachConfig, site *config.Site, component *config.SiteComponent) (string, error) {
	pVars := []string{}
	pResources := []string{}
	pDependsOn := []string{}
	pProviders := []string{}
	for _, plugin := range cfg.Plugins.All() {
		if !pie.Contains(component.Definition.Integrations, plugin.Identifier()) {
			continue
		}

		value, err := plugin.TerraformRenderComponentResources(site.Identifier, component.Name)
		if err != nil {
			return "", err
		}
		pResources = append(pResources, value)

		value, err = plugin.TerraformRenderComponentVars(site.Identifier, component.Name)
		if err != nil {
			return "", err
		}
		pVars = append(pVars, value)

		values, err := plugin.TerraformRenderComponentProviders(site.Identifier, component.Name)
		if err != nil {
			return "", err
		}
		pProviders = append(pProviders, values...)

		values, err = plugin.TerraformRenderComponentDependsOn(site.Identifier, component.Name)
		if err != nil {
			return "", err
		}
		pDependsOn = append(pDependsOn, values...)
	}

	componentVariables, err := variables.InterpolateComponentVars(component.Variables)
	if err != nil {
		return "", err
	}

	componentSecrets, err := variables.InterpolateComponentVars(component.Secrets)
	if err != nil {
		return "", err
	}

	return renderer.componentTemplate.Execute(pongo2.Context{
		"global":             cfg.Global,
		"site":               site,
		"variables":          cfg.Variables,
		"component":          component,
		"componentSecrets":   componentSecrets,
		"componentVariables": componentVariables,
		"definition":         component.Definition,
		"pluginVariables":    pVars,
		"pluginResources":    pResources,
		"pluginProviders":    pProviders,
		"pluginDependsOn":    pDependsOn,
	})
}
